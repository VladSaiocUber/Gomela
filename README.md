# Gomela

Gomela is a full-scale verification tool that verifies message passing
concurrency in Go programs. Gomela takes either the name of a Go's github
project or a list of Go files as input and generates Promela models. These
models are then fed to SPIN to verify that the models are free of global
deadlocks. Gomela also offers the ability to the user to give bounds to the
statically unknown communication-related parameters in the modelss to improve
the accuracy of the verification. These parameters are the variables in the
program that affects the number of goroutines or the size of channels in the Go
program.

## Example

In
[parseFiles](https://github.com/nicolasdilley/Gomela/blob/rewrite/examples/parseFiles.go#L9),
The length of ```files``` determines the length of the channel ```ch``` and the
number of goroutines ```parseFiles``` that will be created during execution.
However, ```files``` is not known at compile time. Therefore, Gomela will
generate a bound with a default value (5) and verify the model with this value.
This value can easily be changed by the user. The model generated by Gomela can
be found
[here](https://github.com/nicolasdilley/Gomela/blob/rewrite/examples/parseFiles.pml#L19).
At line 19, the value of the variable ```files``` has been given a value of 5.
The user can change this value to verify the model with different values.

[FindAll](https://github.com/google/gops/blob/6fb0d860e5fa50629405d9e77e255cd32795967e/goprocess/gp.go#L29),
a function that is contained in the code from one of Go's tools, contains a
global deadlock when the value of ```concurrencyProcesses``` is smaller than the
value of ```pss```.

## How to use
To install and use Gomela, follow these steps:


* Run ```go get github.com/nicolasdilley/gomela && cd ~/go/src/github.com/nicolasdilley/gomela && go install```
* Put in ```./source ``` the folders of the projects that you want Gomela to verify.
* Run ```go build && ./gomela```

To pass a default lower and upper bound for badly formed for loop (including infinite for loops)
use the flags ```-lb=value``` and ```-ub=value``` to give a default ```value``` for the lower and upper bound respectively.

To verify the benchmarks:

* Run  ```git clone http://git.cs.kent.ac.uk/nicolasdilley/gomela && cd gomela && go install && go build```
* Run  ```cp benchmarks/* source && ./gomela```

To verify a list of projects:

* Create a .txt file containing all the github projects that you want to verify with each project name (in the form "creator/project_name") on a seperate line. (see [projects.txt](https://www.github.com/nicolasdilley/Gomela/projects.txt))
* Run ```./gomela -l projects.txt -r```
* The results of the survey (log.html and log.csv) will be contained in ./results with a folder per project containing the Promela models.

To verify a single github repository:

* Run ```./gomela -s creator/project_name -r``` ig. ```./gomela -s nicolasdilley/Gomela -r``` will verify this project.
* The result of the survey will be in ./result and the Promela models under ./results/project_name/\*.pml.


The name of the Promela models are as follow: model_nameOfFuction.pml


The features analysed in the survey are :

* Chan in for - A channel created in a for loop
* Go in for - A goroutine is spawned in a for loop
* Comm Param - A function's parameter that is used as either a for loop bound or a channel bound
* For loop not well formed - A for loop that is not well formed (nor infinite)
* Func as a bound - A for loop has a function as a bound
* Receive as a bound - A for loop has a receive as a bound
* len() as a bound - A bound that is the length of a list
* Struct as a bound - A bound that is of type Struct
* Elem of a struct as a bound - A bound that is an element of a struct (eg, b.a)
* Uses an item of a list as a bound - A bound that is an element of a list (eg, a[0])
* Pointer as a bound - A bound that is a pointer (eg, &a[0], &a)
* Integer as a bound - A bound that is a constant or an Integer (eg, a -> const a := 10, 10)
* Var as a bound - A bound that is a variable(eg, a -> a := 10)


# Tutorial

[FindAll](https://github.com/google/gops/blob/6fb0d860e5fa50629405d9e77e255cd32795967e/goprocess/gp.go#L29)
is a function that is found in an open source project called
[gops](https://github.com/google/gops) which is a command line tool to diagnose
Go processes. This function contains a bug only when a specific criteria is met.
When the number of ```pss``` in the code is bigger than
```concurrencyProcesses```, the send at line 42 will block when the capacity of
the channel is reached causing a global deadlock.

Gomela requires that the Go code that needs to be verified is placed in a folder
in ```./source```. To verify this function, we will place the code from line 29
- 74 in a folder called ```source\test``` and invoke ```./gomela```. Gomela will
automatically generate the Promela model. The promela model generated can be
found
[here](https://github.com/nicolasdilley/Gomela/blob/rewrite/examples/findAll.pml)
Gomela will generate a model for every function in the program that does not
take a channel as a parameter.

`// /Users/redfloyd/go/src/github.com/nicolasdilley/gomela/source/test/test.go
typedef Chandef {
  chan sync = [0] of {int};
  chan async_send = [0] of {int};
  chan async_rcv = [0] of {int};
  chan sending = [0] of {int};
  chan closing = [0] of {bool};
  chan is_closed = [0] of {bool};
  int size = 0;
  int num_msgs = 0;

typedef Wgdef {
  chan Add = [0] of {int};
  chan Wait = [0] of {int};
  int Counter = 0;}

}
`

The first line shows the location of the original program.The ```typedef
Chandef``` is the definition of the channel representation's Gomela uses to
model Go's buffered and unbuffered channel. The ```typedef wg``` defines the
structure that is used to model sync.WaitGroup in Promela.

This is followed by the definition of the ```init``` process which contains
the Promela translation of the body of the function ```FindAll```.

`
  Chandef found;
  bool state = false;
  int pss = 5;
  Wgdef wg;
  Chandef limitCh;
  int i;
`

The ```Chandef``` declaration ```found``` and ```limitCh``` are the Promela
channel that represent the Go channel found [here](https://github.com/google/gops/blob/6fb0d860e5fa50629405d9e77e255cd32795967e/goprocess/gp.go#L38)
and [here](https://github.com/google/gops/blob/6fb0d860e5fa50629405d9e77e255cd32795967e/goprocess/gp.go#L39).

The ```Wgdef``` declaration ```wg``` is the Promela WaitGroup that model the
sync.WaitGroup initialiased [here](https://github.com/google/gops/blob/6fb0d860e5fa50629405d9e77e255cd32795967e/goprocess/gp.go#L36)

```state``` and ```i``` are place holder variables used to hold the value
received from a channel and to uses as the index of for loops respectively.


```
  if
  :: true ->
    goto stop_process
  :: true;
  fi;
```

After that, the call ```ps.Processes()``` is ignored because it does not take a
channel as a parameter. This means that it won't impact the communication of the
model unless the call itself is blocking. In that case it is ok because the
function will be verify seperatly if its definition is given.

```if``` statements in Go are translated as a non-deterministic choice between
the two branches. So in this case, from line 8 - 10 in the Go program, the
```if``` statement is translated into a non-deterministic choice between
returning and continuing with the rest of the function's body. the ```return```
statement is translated as a ```goto``` statement which points to the end of the
body of the function.

```
  run wgMonitor(wg);
  wg.Add!pss;
  run sync_monitor(found);

  if
  :: 10 > 0 ->
    limitCh.size = 10;
    run emptyChan(limitCh)
  :: else ->
    run sync_monitor(limitCh)
  fi;
```

After that, the model spawns a monitor for the WaitGroup to monitor and manage
the state of the sync.WaitGroup. The next line models the sync.Waitgroup.Add(x)
which add x to the counter of the WaitGroup by sending that value over the
channel Add. That value is then receive on line 104, added to the counter on
line 105 and a check is done on line 106 to verify that the counter is not
smaller that 0 using the ```assert``` statement in Promela.

To monitor the states of the channels in Promela, we use different monitors
which varies according to the number of messages that the channel contains, if
the channel is closed or not and if it is synchronous or not.

A ```sync_monitor``` is spawned to monitor the channel ```found```.
```sync_monitor``` is used to monitor synchronous channel.

This is followed by an ```if``` statement which spawns a monitor for an
asynchronous channel if the size of the channel ```limitCh``` is bigger than 0
or a synchronous channel if its not. Since the size of ```limitCh``` in the
source code is a constant, the actual value of the constant is given.
```emptyChan``` is used to monitor an empty asynchronous channel.

```
    for(i : 1.. pss) {
for10:
    if
    :: limitCh.async_send!0;
    :: limitCh.sync!0 ->
      limitCh.sending?0
    fi;
    run Anonymous0(found,limitCh,wg)
  };
```

Finally, the ```range``` statement which range over each element in ```pss```
and spawns an anonymous function after sending to limitCh. Since the number of
threads in a Promela model needs to be known at compile time, the value of
```pss``` needs to be known. Therefore, ```pss``` is a communication parameter.
To verify the model with a different value for ```pss```, change the value given
at line 23.

Send and receive statements are translated as a choice between sending or
receiving on an async channel and on a sync channel. This is because as stated
above the size of a channel affects which monitors will be assigned to it.
Sending or receiving on both channel allows to account for both options.





